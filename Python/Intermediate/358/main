## [2018-04-25] Challenge #358 [Intermediate] Everyone's A Winner!
## https://www.reddit.com/r/dailyprogrammer/comments/8ewq2e/20180425_challenge_358_intermediate_everyones_a/

import re

# file_path = r"C:\Users\ml044041\Python\Text Docs\NBA.txt" # work
file_path = r"I:\Python Scripts\Text_Files\NBA.txt" # home

with open(file_path, "r") as content:
    file = content.read().splitlines()
    # file2 = content.read()
# file2 = open(file_path).readlines()
# print(file2)
# print(file)
mylist = []
def list_in_list(mylist):
    for line in file:
        # extraction = re.findall(r"(?<=[ @])(\w+)(?=[ ])",line)
        extraction_2 = re.split(r"\s+", line)
        # mylist.append(extraction)
        mylist.append(extraction_2[1:])
    return mylist

def initial_clean(mylist):
    removed_empty_lists = [myl for myl in mylist if len(myl) != 0] # Removes empty lists
    new_list = []

    for list in removed_empty_lists: # Only returns lists with numbers
        for elt in list:
            if elt.isdigit():
                new_list.append(list)
                break
    return new_list

## join up the text in each list, use enumerate

def join_scores(mylist):
    new_list = []
    for list in mylist:
        # for index in range(1,len(list)):
        #     if list[index-1].isstr() and list[index].str():
        #         new_inner_list += list[index-1] + " " + list[index]
        #     else:
        #         new_inner_list.append(list[index])
        inner_list = []
        current_string = ""
        for element in list:
            if element.isdigit():
                current_string = current_string[:-1]
                inner_list.append(current_string)
                inner_list.append(element)
                current_string = ""

            elif isinstance (element, str):
                if re.search("@", element):
                    element = element [1:]
                element += " "
                current_string += element
            else:
                inner_list.append(current_string)
                inner_list.append(element)
                current_string = ""

        new_list.append(inner_list)
        # print (type(inner_list))
        # break
        # print (len(new_list))

    return new_list

def clean_two(mylist):
    for list in mylist:
        if len(list) != 4:
            mylist.remove(list)
    return mylist

def populate_teams(mylist):
    teams = []
    for list in mylist:
        for element in list:
            if not element.isdigit() and element not in teams:
                # print (element)
                teams.append(element)
    return teams

def winner(mylist):
    number_of_wins = {}
    for list in mylist:
        # print(list)
        if list[1] > list[-1]:
            number_of_wins.setdefault(list[0],0)
            number_of_wins[list[0]] += 1
        elif list[1] < list[-1]:
            number_of_wins.setdefault(list[2], 0)
            number_of_wins[list[2]] += 1

    winner_score = 0
    temp_winner = ""

    for team, wins in number_of_wins.items():
        if wins > winner_score:
            # print(team)
            winner_score = wins
            temp_winner = team
    print(temp_winner)
    print("Winner is:", temp_winner, "With a total number of victories of:", winner_score)
    return number_of_wins

def winning_team_in_match(mylist, switch):

    mylist2 = [int(x) if x.isdigit() else x for x in mylist]
    # for x in mylist:
    #     if x.isdigit():
    #         mylist2.append(int(x))
    #     else:
    #         mylist2.append(x)


    if mylist2[1] > mylist2[-1]:
        print("first")
        switch = True
        return(mylist2[0], switch)
    elif mylist2[1] < mylist2[-1]:
        # print("mylist[1]:", mylist[1],type(mylist[1]))
        # print("mylist[-1]:", mylist[-1],type(mylist[-1]))
        print("second")
        switch = True
        return(mylist2[2], switch)


def transitive (team_list, all_scores):
    mod_team_list = all_scores.copy()
    winning_teams = ["Ferris St",]
    switch = True
    switch_counter = 0
    while switch:
        switch = False
        switch_counter += 1
        for team in winning_teams:
            for match in mod_team_list:
                if team in match:
                    print("Team:", team, "matched")
                    print("Match:", match)

                    winners, switch = (winning_team_in_match(match, switch))


                    if winners not in winning_teams:
                        winning_teams.append(winners)
                    print("Winners:", winners)
                    print()
                    print(switch_counter)
                    print(switch)
                    print("Matches left to sort:", len(mod_team_list))
                    mod_team_list.remove(match)
                    print("----------------------")
            print("********")
            print("Teams not matched:", team)
            print("Match:", match)

    return winning_teams

def main():

    foo = list_in_list(mylist)
    initial_clean(foo)
    bar = join_scores(foo)
    bar_2 = initial_clean(bar)
    bar_3 = (clean_two(bar_2))
    teams = populate_teams(bar_3)

    print(len(transitive(teams, bar_3)) - 1) # -1 to remove the overall winner

if __name__ == "__main__":
    main()


# Return list with all teams
# Overall winner = number 1 so can remove that team from this list
# Then any team that beat that team you remove from the over all list all the way down
